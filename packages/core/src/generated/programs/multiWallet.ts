/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from "gill";
import {
  type ParsedAddWhitelistedAddressTreesInstruction,
  type ParsedChangeConfigCompressedInstruction,
  type ParsedChangeConfigInstruction,
  type ParsedCompressSettingsAccountInstruction,
  type ParsedCreateDomainConfigInstruction,
  type ParsedCreateDomainUserAccountInstruction,
  type ParsedCreateGlobalCounterInstruction,
  type ParsedCreateMultiWalletCompressedInstruction,
  type ParsedCreateUserAccountsInstruction,
  type ParsedDecompressSettingsAccountInstruction,
  type ParsedDisableDomainConfigInstruction,
  type ParsedEditDomainConfigInstruction,
  type ParsedEditTransactionManagerUrlInstruction,
  type ParsedMigrateCompressedSettingsInstruction,
  type ParsedMigrateCompressedUsersInstruction,
  type ParsedNativeTransferIntentCompressedInstruction,
  type ParsedNativeTransferIntentInstruction,
  type ParsedTokenTransferIntentCompressedInstruction,
  type ParsedTokenTransferIntentInstruction,
  type ParsedTransactionBufferCloseCompressedInstruction,
  type ParsedTransactionBufferCloseInstruction,
  type ParsedTransactionBufferCreateCompressedInstruction,
  type ParsedTransactionBufferCreateInstruction,
  type ParsedTransactionBufferExecuteCompressedInstruction,
  type ParsedTransactionBufferExecuteInstruction,
  type ParsedTransactionBufferExtendCompressedInstruction,
  type ParsedTransactionBufferExtendInstruction,
  type ParsedTransactionBufferVoteCompressedInstruction,
  type ParsedTransactionBufferVoteInstruction,
  type ParsedTransactionExecuteCompressedInstruction,
  type ParsedTransactionExecuteInstruction,
  type ParsedTransactionExecuteSyncCompressedInstruction,
  type ParsedTransactionExecuteSyncInstruction,
} from "../instructions";

export const MULTI_WALLET_PROGRAM_ADDRESS =
  "reviR1xysEChySVSWGa43a6oJ2boJYTJhwRjo8KJhhT" as Address<"reviR1xysEChySVSWGa43a6oJ2boJYTJhwRjo8KJhhT">;

export enum MultiWalletAccount {
  DomainConfig,
  GlobalCounter,
  Settings,
  TransactionBuffer,
  WhitelistedAddressTree,
}

export function identifyMultiWalletAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): MultiWalletAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([201, 232, 212, 229, 59, 241, 106, 197])
      ),
      0
    )
  ) {
    return MultiWalletAccount.DomainConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([42, 206, 176, 58, 175, 129, 130, 233])
      ),
      0
    )
  ) {
    return MultiWalletAccount.GlobalCounter;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([223, 179, 163, 190, 177, 224, 67, 173])
      ),
      0
    )
  ) {
    return MultiWalletAccount.Settings;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 36, 35, 219, 93, 225, 110, 96])
      ),
      0
    )
  ) {
    return MultiWalletAccount.TransactionBuffer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([105, 23, 173, 2, 197, 255, 80, 87])
      ),
      0
    )
  ) {
    return MultiWalletAccount.WhitelistedAddressTree;
  }
  throw new Error(
    "The provided account could not be identified as a multiWallet account."
  );
}

export enum MultiWalletInstruction {
  AddWhitelistedAddressTrees,
  ChangeConfig,
  ChangeConfigCompressed,
  CompressSettingsAccount,
  CreateDomainConfig,
  CreateDomainUserAccount,
  CreateGlobalCounter,
  CreateMultiWalletCompressed,
  CreateUserAccounts,
  DecompressSettingsAccount,
  DisableDomainConfig,
  EditDomainConfig,
  EditTransactionManagerUrl,
  MigrateCompressedSettings,
  MigrateCompressedUsers,
  NativeTransferIntent,
  NativeTransferIntentCompressed,
  TokenTransferIntent,
  TokenTransferIntentCompressed,
  TransactionBufferClose,
  TransactionBufferCloseCompressed,
  TransactionBufferCreate,
  TransactionBufferCreateCompressed,
  TransactionBufferExecute,
  TransactionBufferExecuteCompressed,
  TransactionBufferExtend,
  TransactionBufferExtendCompressed,
  TransactionBufferVote,
  TransactionBufferVoteCompressed,
  TransactionExecute,
  TransactionExecuteCompressed,
  TransactionExecuteSync,
  TransactionExecuteSyncCompressed,
}

export function identifyMultiWalletInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): MultiWalletInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([7])),
      0
    )
  ) {
    return MultiWalletInstruction.AddWhitelistedAddressTrees;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([8])),
      0
    )
  ) {
    return MultiWalletInstruction.ChangeConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([19])),
      0
    )
  ) {
    return MultiWalletInstruction.ChangeConfigCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([16])),
      0
    )
  ) {
    return MultiWalletInstruction.CompressSettingsAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([0])),
      0
    )
  ) {
    return MultiWalletInstruction.CreateDomainConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([4])),
      0
    )
  ) {
    return MultiWalletInstruction.CreateDomainUserAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([3])),
      0
    )
  ) {
    return MultiWalletInstruction.CreateGlobalCounter;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([18])),
      0
    )
  ) {
    return MultiWalletInstruction.CreateMultiWalletCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([5])),
      0
    )
  ) {
    return MultiWalletInstruction.CreateUserAccounts;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([17])),
      0
    )
  ) {
    return MultiWalletInstruction.DecompressSettingsAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([2])),
      0
    )
  ) {
    return MultiWalletInstruction.DisableDomainConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([1])),
      0
    )
  ) {
    return MultiWalletInstruction.EditDomainConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([6])),
      0
    )
  ) {
    return MultiWalletInstruction.EditTransactionManagerUrl;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([32])),
      0
    )
  ) {
    return MultiWalletInstruction.MigrateCompressedSettings;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([31])),
      0
    )
  ) {
    return MultiWalletInstruction.MigrateCompressedUsers;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([29])),
      0
    )
  ) {
    return MultiWalletInstruction.NativeTransferIntent;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([27])),
      0
    )
  ) {
    return MultiWalletInstruction.NativeTransferIntentCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([30])),
      0
    )
  ) {
    return MultiWalletInstruction.TokenTransferIntent;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([28])),
      0
    )
  ) {
    return MultiWalletInstruction.TokenTransferIntentCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([12])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferClose;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([23])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferCloseCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([9])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferCreate;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([20])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferCreateCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([13])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferExecute;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([24])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferExecuteCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([11])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferExtend;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([22])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferExtendCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([10])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferVote;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([21])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionBufferVoteCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([14])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionExecute;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([25])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionExecuteCompressed;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([15])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionExecuteSync;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([26])),
      0
    )
  ) {
    return MultiWalletInstruction.TransactionExecuteSyncCompressed;
  }
  throw new Error(
    "The provided instruction could not be identified as a multiWallet instruction."
  );
}

export type ParsedMultiWalletInstruction<
  TProgram extends string = "reviR1xysEChySVSWGa43a6oJ2boJYTJhwRjo8KJhhT",
> =
  | ({
      instructionType: MultiWalletInstruction.AddWhitelistedAddressTrees;
    } & ParsedAddWhitelistedAddressTreesInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.ChangeConfig;
    } & ParsedChangeConfigInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.ChangeConfigCompressed;
    } & ParsedChangeConfigCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.CompressSettingsAccount;
    } & ParsedCompressSettingsAccountInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.CreateDomainConfig;
    } & ParsedCreateDomainConfigInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.CreateDomainUserAccount;
    } & ParsedCreateDomainUserAccountInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.CreateGlobalCounter;
    } & ParsedCreateGlobalCounterInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.CreateMultiWalletCompressed;
    } & ParsedCreateMultiWalletCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.CreateUserAccounts;
    } & ParsedCreateUserAccountsInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.DecompressSettingsAccount;
    } & ParsedDecompressSettingsAccountInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.DisableDomainConfig;
    } & ParsedDisableDomainConfigInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.EditDomainConfig;
    } & ParsedEditDomainConfigInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.EditTransactionManagerUrl;
    } & ParsedEditTransactionManagerUrlInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.MigrateCompressedSettings;
    } & ParsedMigrateCompressedSettingsInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.MigrateCompressedUsers;
    } & ParsedMigrateCompressedUsersInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.NativeTransferIntent;
    } & ParsedNativeTransferIntentInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.NativeTransferIntentCompressed;
    } & ParsedNativeTransferIntentCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TokenTransferIntent;
    } & ParsedTokenTransferIntentInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TokenTransferIntentCompressed;
    } & ParsedTokenTransferIntentCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferClose;
    } & ParsedTransactionBufferCloseInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferCloseCompressed;
    } & ParsedTransactionBufferCloseCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferCreate;
    } & ParsedTransactionBufferCreateInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferCreateCompressed;
    } & ParsedTransactionBufferCreateCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferExecute;
    } & ParsedTransactionBufferExecuteInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferExecuteCompressed;
    } & ParsedTransactionBufferExecuteCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferExtend;
    } & ParsedTransactionBufferExtendInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferExtendCompressed;
    } & ParsedTransactionBufferExtendCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferVote;
    } & ParsedTransactionBufferVoteInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionBufferVoteCompressed;
    } & ParsedTransactionBufferVoteCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionExecute;
    } & ParsedTransactionExecuteInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionExecuteCompressed;
    } & ParsedTransactionExecuteCompressedInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionExecuteSync;
    } & ParsedTransactionExecuteSyncInstruction<TProgram>)
  | ({
      instructionType: MultiWalletInstruction.TransactionExecuteSyncCompressed;
    } & ParsedTransactionExecuteSyncCompressedInstruction<TProgram>);
