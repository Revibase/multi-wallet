/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type ReadonlyUint8Array,
} from 'gill';
import {
  getAdditionalMetadataDecoder,
  getAdditionalMetadataEncoder,
  type AdditionalMetadata,
  type AdditionalMetadataArgs,
} from '.';

/** Used for onchain serialization */
export type TokenMetadata = {
  /**
   * The authority that can sign to update the metadata
   * None if zero
   */
  updateAuthority: Address;
  /**
   * The associated mint, used to counter spoofing to be sure that metadata
   * belongs to a particular mint
   */
  mint: Address;
  /** The longer name of the token */
  name: ReadonlyUint8Array;
  /** The shortened symbol for the token */
  symbol: ReadonlyUint8Array;
  /** The URI pointing to richer metadata */
  uri: ReadonlyUint8Array;
  /**
   * Any additional metadata about the token as key-value pairs. The program
   * must avoid storing the same key twice.
   */
  additionalMetadata: Array<AdditionalMetadata>;
};

export type TokenMetadataArgs = {
  /**
   * The authority that can sign to update the metadata
   * None if zero
   */
  updateAuthority: Address;
  /**
   * The associated mint, used to counter spoofing to be sure that metadata
   * belongs to a particular mint
   */
  mint: Address;
  /** The longer name of the token */
  name: ReadonlyUint8Array;
  /** The shortened symbol for the token */
  symbol: ReadonlyUint8Array;
  /** The URI pointing to richer metadata */
  uri: ReadonlyUint8Array;
  /**
   * Any additional metadata about the token as key-value pairs. The program
   * must avoid storing the same key twice.
   */
  additionalMetadata: Array<AdditionalMetadataArgs>;
};

export function getTokenMetadataEncoder(): Encoder<TokenMetadataArgs> {
  return getStructEncoder([
    ['updateAuthority', getAddressEncoder()],
    ['mint', getAddressEncoder()],
    ['name', addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ['symbol', addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ['uri', addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ['additionalMetadata', getArrayEncoder(getAdditionalMetadataEncoder())],
  ]);
}

export function getTokenMetadataDecoder(): Decoder<TokenMetadata> {
  return getStructDecoder([
    ['updateAuthority', getAddressDecoder()],
    ['mint', getAddressDecoder()],
    ['name', addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ['symbol', addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ['uri', addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ['additionalMetadata', getArrayDecoder(getAdditionalMetadataDecoder())],
  ]);
}

export function getTokenMetadataCodec(): Codec<
  TokenMetadataArgs,
  TokenMetadata
> {
  return combineCodec(getTokenMetadataEncoder(), getTokenMetadataDecoder());
}
