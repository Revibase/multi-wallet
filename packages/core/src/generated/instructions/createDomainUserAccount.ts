/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableSignerAccount,
} from "gill";
import { parseRemainingAccounts } from "../../hooked";
import { MULTI_WALLET_PROGRAM_ADDRESS } from "../programs";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared";
import {
  getLinkWalletArgsDecoder,
  getLinkWalletArgsEncoder,
  getProofArgsDecoder,
  getProofArgsEncoder,
  getSecp256r1PubkeyDecoder,
  getSecp256r1PubkeyEncoder,
  getUserCreationArgsDecoder,
  getUserCreationArgsEncoder,
  type LinkWalletArgs,
  type LinkWalletArgsArgs,
  type ProofArgs,
  type ProofArgsArgs,
  type Secp256r1Pubkey,
  type Secp256r1PubkeyArgs,
  type UserCreationArgs,
  type UserCreationArgsArgs,
} from "../types";

export const CREATE_DOMAIN_USER_ACCOUNT_DISCRIMINATOR = new Uint8Array([4]);

export function getCreateDomainUserAccountDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 1).encode(
    CREATE_DOMAIN_USER_ACCOUNT_DISCRIMINATOR
  );
}

export type CreateDomainUserAccountInstruction<
  TProgram extends string = typeof MULTI_WALLET_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountDomainConfig extends string | AccountMeta<string> = string,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountWhitelistedAddressTrees extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountDomainConfig extends string
        ? ReadonlyAccount<TAccountDomainConfig>
        : TAccountDomainConfig,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            AccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountWhitelistedAddressTrees extends string
        ? ReadonlyAccount<TAccountWhitelistedAddressTrees>
        : TAccountWhitelistedAddressTrees,
      ...TRemainingAccounts,
    ]
  >;

export type CreateDomainUserAccountInstructionData = {
  discriminator: ReadonlyUint8Array;
  compressedProofArgs: ProofArgs;
  member: Secp256r1Pubkey;
  isPermanentMember: boolean;
  userAccountCreationArgs: UserCreationArgs;
  linkWalletArgs: Option<LinkWalletArgs>;
};

export type CreateDomainUserAccountInstructionDataArgs = {
  compressedProofArgs: ProofArgsArgs;
  member: Secp256r1PubkeyArgs;
  isPermanentMember: boolean;
  userAccountCreationArgs: UserCreationArgsArgs;
  linkWalletArgs: OptionOrNullable<LinkWalletArgsArgs>;
};

export function getCreateDomainUserAccountInstructionDataEncoder(): Encoder<CreateDomainUserAccountInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 1)],
      ["compressedProofArgs", getProofArgsEncoder()],
      ["member", getSecp256r1PubkeyEncoder()],
      ["isPermanentMember", getBooleanEncoder()],
      ["userAccountCreationArgs", getUserCreationArgsEncoder()],
      ["linkWalletArgs", getOptionEncoder(getLinkWalletArgsEncoder())],
    ]),
    (value) => ({
      ...value,
      discriminator: CREATE_DOMAIN_USER_ACCOUNT_DISCRIMINATOR,
    })
  );
}

export function getCreateDomainUserAccountInstructionDataDecoder(): Decoder<CreateDomainUserAccountInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 1)],
    ["compressedProofArgs", getProofArgsDecoder()],
    ["member", getSecp256r1PubkeyDecoder()],
    ["isPermanentMember", getBooleanDecoder()],
    ["userAccountCreationArgs", getUserCreationArgsDecoder()],
    ["linkWalletArgs", getOptionDecoder(getLinkWalletArgsDecoder())],
  ]);
}

export function getCreateDomainUserAccountInstructionDataCodec(): Codec<
  CreateDomainUserAccountInstructionDataArgs,
  CreateDomainUserAccountInstructionData
> {
  return combineCodec(
    getCreateDomainUserAccountInstructionDataEncoder(),
    getCreateDomainUserAccountInstructionDataDecoder()
  );
}

export type CreateDomainUserAccountInstructionExtraArgs = {
  remainingAccounts: Array<{ address: Address; role: number }>;
};

export type CreateDomainUserAccountAsyncInput<
  TAccountPayer extends string = string,
  TAccountDomainConfig extends string = string,
  TAccountAuthority extends string = string,
  TAccountWhitelistedAddressTrees extends string = string,
> = {
  payer: TransactionSigner<TAccountPayer>;
  domainConfig: Address<TAccountDomainConfig>;
  authority: TransactionSigner<TAccountAuthority>;
  whitelistedAddressTrees?: Address<TAccountWhitelistedAddressTrees>;
  compressedProofArgs: CreateDomainUserAccountInstructionDataArgs["compressedProofArgs"];
  member: CreateDomainUserAccountInstructionDataArgs["member"];
  isPermanentMember: CreateDomainUserAccountInstructionDataArgs["isPermanentMember"];
  userAccountCreationArgs: CreateDomainUserAccountInstructionDataArgs["userAccountCreationArgs"];
  linkWalletArgs: CreateDomainUserAccountInstructionDataArgs["linkWalletArgs"];
  remainingAccounts: CreateDomainUserAccountInstructionExtraArgs["remainingAccounts"];
};

export async function getCreateDomainUserAccountInstructionAsync<
  TAccountPayer extends string,
  TAccountDomainConfig extends string,
  TAccountAuthority extends string,
  TAccountWhitelistedAddressTrees extends string,
  TProgramAddress extends Address = typeof MULTI_WALLET_PROGRAM_ADDRESS,
>(
  input: CreateDomainUserAccountAsyncInput<
    TAccountPayer,
    TAccountDomainConfig,
    TAccountAuthority,
    TAccountWhitelistedAddressTrees
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  CreateDomainUserAccountInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountDomainConfig,
    TAccountAuthority,
    TAccountWhitelistedAddressTrees
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? MULTI_WALLET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    domainConfig: { value: input.domainConfig ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false },
    whitelistedAddressTrees: {
      value: input.whitelistedAddressTrees ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolver scope.
  const resolverScope = { programAddress, accounts, args };

  // Resolve default values.
  if (!accounts.whitelistedAddressTrees.value) {
    accounts.whitelistedAddressTrees.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            119, 104, 105, 116, 101, 108, 105, 115, 116, 101, 100, 95, 97, 100,
            100, 114, 101, 115, 115, 95, 116, 114, 101, 101, 115,
          ])
        ),
      ],
    });
  }

  // Remaining accounts.
  const remainingAccounts: AccountMeta[] =
    parseRemainingAccounts(resolverScope);

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.domainConfig),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.whitelistedAddressTrees),
      ...remainingAccounts,
    ],
    data: getCreateDomainUserAccountInstructionDataEncoder().encode(
      args as CreateDomainUserAccountInstructionDataArgs
    ),
    programAddress,
  } as CreateDomainUserAccountInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountDomainConfig,
    TAccountAuthority,
    TAccountWhitelistedAddressTrees
  >);
}

export type CreateDomainUserAccountInput<
  TAccountPayer extends string = string,
  TAccountDomainConfig extends string = string,
  TAccountAuthority extends string = string,
  TAccountWhitelistedAddressTrees extends string = string,
> = {
  payer: TransactionSigner<TAccountPayer>;
  domainConfig: Address<TAccountDomainConfig>;
  authority: TransactionSigner<TAccountAuthority>;
  whitelistedAddressTrees: Address<TAccountWhitelistedAddressTrees>;
  compressedProofArgs: CreateDomainUserAccountInstructionDataArgs["compressedProofArgs"];
  member: CreateDomainUserAccountInstructionDataArgs["member"];
  isPermanentMember: CreateDomainUserAccountInstructionDataArgs["isPermanentMember"];
  userAccountCreationArgs: CreateDomainUserAccountInstructionDataArgs["userAccountCreationArgs"];
  linkWalletArgs: CreateDomainUserAccountInstructionDataArgs["linkWalletArgs"];
  remainingAccounts: CreateDomainUserAccountInstructionExtraArgs["remainingAccounts"];
};

export function getCreateDomainUserAccountInstruction<
  TAccountPayer extends string,
  TAccountDomainConfig extends string,
  TAccountAuthority extends string,
  TAccountWhitelistedAddressTrees extends string,
  TProgramAddress extends Address = typeof MULTI_WALLET_PROGRAM_ADDRESS,
>(
  input: CreateDomainUserAccountInput<
    TAccountPayer,
    TAccountDomainConfig,
    TAccountAuthority,
    TAccountWhitelistedAddressTrees
  >,
  config?: { programAddress?: TProgramAddress }
): CreateDomainUserAccountInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountDomainConfig,
  TAccountAuthority,
  TAccountWhitelistedAddressTrees
> {
  // Program address.
  const programAddress = config?.programAddress ?? MULTI_WALLET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    domainConfig: { value: input.domainConfig ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false },
    whitelistedAddressTrees: {
      value: input.whitelistedAddressTrees ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolver scope.
  const resolverScope = { programAddress, accounts, args };

  // Remaining accounts.
  const remainingAccounts: AccountMeta[] =
    parseRemainingAccounts(resolverScope);

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.domainConfig),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.whitelistedAddressTrees),
      ...remainingAccounts,
    ],
    data: getCreateDomainUserAccountInstructionDataEncoder().encode(
      args as CreateDomainUserAccountInstructionDataArgs
    ),
    programAddress,
  } as CreateDomainUserAccountInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountDomainConfig,
    TAccountAuthority,
    TAccountWhitelistedAddressTrees
  >);
}

export type ParsedCreateDomainUserAccountInstruction<
  TProgram extends string = typeof MULTI_WALLET_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    payer: TAccountMetas[0];
    domainConfig: TAccountMetas[1];
    authority: TAccountMetas[2];
    whitelistedAddressTrees: TAccountMetas[3];
  };
  data: CreateDomainUserAccountInstructionData;
};

export function parseCreateDomainUserAccountInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedCreateDomainUserAccountInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 4) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      domainConfig: getNextAccount(),
      authority: getNextAccount(),
      whitelistedAddressTrees: getNextAccount(),
    },
    data: getCreateDomainUserAccountInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
